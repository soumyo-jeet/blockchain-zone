#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0 1000
    bytecblock "total_entries" "creator" "entry_fee"
    // smart_contracts/lottery_contract/contract.py:5
    // class LotteryContract(ARC4Contract):
    pushbytes 0x9a7dcd60 // method "del_contract()void"
    txna ApplicationArgs 0
    match main_del_contract_route@2

main_switch_case_next@3:
    // smart_contracts/lottery_contract/contract.py:5
    // class LotteryContract(ARC4Contract):
    txn OnCompletion
    !
    assert
    txn ApplicationID
    bz main_create_NoOp@8
    pushbytess 0x87ea49d7 0xbe0bdebf // method "enter_lottery(pay)void", method "pick_winner()void"
    txna ApplicationArgs 0
    match enter_lottery pick_winner
    err

main_create_NoOp@8:
    // smart_contracts/lottery_contract/contract.py:5
    // class LotteryContract(ARC4Contract):
    pushbytes 0xa03b81d2 // method "create_application(uint64)void"
    txna ApplicationArgs 0
    match create_application
    err

main_del_contract_route@2:
    // smart_contracts/lottery_contract/contract.py:44
    // @abimethod(allow_actions=["DeleteApplication"])
    txn OnCompletion
    pushint 5 // DeleteApplication
    ==
    txn ApplicationID
    &&
    assert
    b del_contract


// smart_contracts.lottery_contract.contract.LotteryContract.create_application[routing]() -> void:
create_application:
    // smart_contracts/lottery_contract/contract.py:10-11
    // # method to initiate the contract
    // @abimethod(create="require")
    txna ApplicationArgs 1
    dup
    len
    pushint 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/lottery_contract/contract.py:13
    // self.entry_fee = entry_fee
    bytec_2 // "entry_fee"
    swap
    app_global_put
    // smart_contracts/lottery_contract/contract.py:14
    // self.total_entries = UInt64(0)
    bytec_0 // "total_entries"
    intc_1 // 0
    app_global_put
    // smart_contracts/lottery_contract/contract.py:15
    // self.creator = Global.creator_address # Store the address of the perspn who has initiate the method
    bytec_1 // "creator"
    global CreatorAddress
    app_global_put
    // smart_contracts/lottery_contract/contract.py:10-11
    // # method to initiate the contract
    // @abimethod(create="require")
    intc_0 // 1
    return


// smart_contracts.lottery_contract.contract.LotteryContract.enter_lottery[routing]() -> void:
enter_lottery:
    // smart_contracts/lottery_contract/contract.py:17
    // @abimethod
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/lottery_contract/contract.py:19-20
    // # check if the payment is sent to the contract address
    // assert payment_txn.receiver == Global.current_application_address
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // smart_contracts/lottery_contract/contract.py:21-22
    // # check if the payment ammount equals the entry fee
    // assert payment_txn.amount == self.entry_fee
    gtxns Amount
    intc_1 // 0
    bytec_2 // "entry_fee"
    app_global_get_ex
    assert // check self.entry_fee exists
    ==
    assert
    // smart_contracts/lottery_contract/contract.py:24-25
    // # if all the above checkpoints pass permit the participant to enter
    // self.total_entries+= UInt64(1)
    intc_1 // 0
    bytec_0 // "total_entries"
    app_global_get_ex
    assert // check self.total_entries exists
    intc_0 // 1
    +
    bytec_0 // "total_entries"
    swap
    app_global_put
    // smart_contracts/lottery_contract/contract.py:17
    // @abimethod
    intc_0 // 1
    return


// smart_contracts.lottery_contract.contract.LotteryContract.pick_winner[routing]() -> void:
pick_winner:
    // smart_contracts/lottery_contract/contract.py:29-30
    // # check if the caller is the owner of the contract
    // assert Txn.sender == self.creator
    txn Sender
    intc_1 // 0
    bytec_1 // "creator"
    app_global_get_ex
    assert // check self.creator exists
    ==
    assert
    // smart_contracts/lottery_contract/contract.py:31
    // assert self.total_entries > UInt64(0)
    intc_1 // 0
    bytec_0 // "total_entries"
    app_global_get_ex
    assert // check self.total_entries exists
    dup
    assert
    // smart_contracts/lottery_contract/contract.py:33
    // round_num = Global.round
    global Round
    // smart_contracts/lottery_contract/contract.py:34
    // rand_num = round_num % self.total_entries
    swap
    %
    // smart_contracts/lottery_contract/contract.py:36
    // winner = gtxn.Transaction(rand_num).sender
    gtxns Sender
    // smart_contracts/lottery_contract/contract.py:38-42
    // itxn.Payment (
    //     receiver= winner,
    //     amount= Global.current_application_address.balance - UInt64(1_000_000), # total - 1 algo
    //     fee=1000
    // ).submit()
    itxn_begin
    // smart_contracts/lottery_contract/contract.py:40
    // amount= Global.current_application_address.balance - UInt64(1_000_000), # total - 1 algo
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    pushint 1000000
    -
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/lottery_contract/contract.py:38
    // itxn.Payment (
    intc_0 // pay
    itxn_field TypeEnum
    // smart_contracts/lottery_contract/contract.py:41
    // fee=1000
    intc_2 // 1000
    itxn_field Fee
    // smart_contracts/lottery_contract/contract.py:38-42
    // itxn.Payment (
    //     receiver= winner,
    //     amount= Global.current_application_address.balance - UInt64(1_000_000), # total - 1 algo
    //     fee=1000
    // ).submit()
    itxn_submit
    // smart_contracts/lottery_contract/contract.py:27
    // @abimethod
    intc_0 // 1
    return


// smart_contracts.lottery_contract.contract.LotteryContract.del_contract[routing]() -> void:
del_contract:
    // smart_contracts/lottery_contract/contract.py:46-47
    // # check if the caller is the owner
    // assert Txn.sender == self.creator
    txn Sender
    intc_1 // 0
    bytec_1 // "creator"
    app_global_get_ex
    assert // check self.creator exists
    swap
    dig 1
    ==
    assert
    // smart_contracts/lottery_contract/contract.py:49-54
    // # send all the balance remains in the contract to the owner
    // itxn.Payment(
    //     receiver= self.creator,
    //     close_remainder_to=self.creator,
    //     fee = 1000
    // ).submit()
    itxn_begin
    dup
    itxn_field CloseRemainderTo
    itxn_field Receiver
    // smart_contracts/lottery_contract/contract.py:49-50
    // # send all the balance remains in the contract to the owner
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    // smart_contracts/lottery_contract/contract.py:53
    // fee = 1000
    intc_2 // 1000
    itxn_field Fee
    // smart_contracts/lottery_contract/contract.py:49-54
    // # send all the balance remains in the contract to the owner
    // itxn.Payment(
    //     receiver= self.creator,
    //     close_remainder_to=self.creator,
    //     fee = 1000
    // ).submit()
    itxn_submit
    // smart_contracts/lottery_contract/contract.py:44
    // @abimethod(allow_actions=["DeleteApplication"])
    intc_0 // 1
    return
